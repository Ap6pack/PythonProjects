from scapy.all import IP, sniff
import subprocess
import time

# Dictionary to keep track of packet counts per IP and timestamp
ip_count = {}

# Threshold for number of packets allowed from a single IP
PACKET_THRESHOLD = 100
# Time limit for tracking IPs (e.g., 60 seconds)
TIME_WINDOW = 60

# Block an IP using iptables (for Linux systems)
def block_ip(ip):
    try:
        # Block the IP using iptables
        subprocess.run(['iptables', '-A', 'INPUT', '-s', ip, '-j', 'DROP'], check=True)
        print(f"Blocked IP: {ip}")
    except subprocess.CalledProcessError as e:
        print(f"Error blocking IP {ip}: {e}")

# Clean up old IPs from the dictionary based on a time window
def clean_old_ips():
    current_time = time.time()
    for ip in list(ip_count.keys()):
        last_seen, count = ip_count[ip]
        if current_time - last_seen > TIME_WINDOW:
            del ip_count[ip]

# Function to detect a possible DDoS attack
def detect_ddos(packet):
    global ip_count
    if IP in packet:
        ip_src = packet[IP].src
        current_time = time.time()
        
        # Clean up old IPs periodically
        clean_old_ips()
        
        # Update packet count for the source IP
        if ip_src in ip_count:
            last_seen, count = ip_count[ip_src]
            ip_count[ip_src] = (current_time, count + 1)
        else:
            ip_count[ip_src] = (current_time, 1)
        
        # If packet count exceeds the threshold, block the IP
        if ip_count[ip_src][1] > PACKET_THRESHOLD:
            print(f"Possible DDoS attack from {ip_src}")
            block_ip(ip_src)
            del ip_count[ip_src]  # Stop tracking once blocked

# Start sniffing network traffic and apply the detect_ddos function on captured IP packets
sniff(filter="ip", prn=detect_ddos)
